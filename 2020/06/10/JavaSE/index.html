<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java," />










<meta name="description" content="我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="http://yoursite.com/2020/06/10/JavaSE/index.html">
<meta property="og:site_name" content="Panda的技术笔记">
<meta property="og:description" content="我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/image/JavaSE.png">
<meta property="og:image" content="http://yoursite.com/image/JDKJRE.png">
<meta property="og:image" content="http://yoursite.com/image/class.png">
<meta property="og:image" content="http://yoursite.com/image/exception.png">
<meta property="og:image" content="http://yoursite.com/image/log1.png">
<meta property="og:image" content="http://yoursite.com/image/log2.png">
<meta property="og:image" content="http://yoursite.com/image/@Documented.png">
<meta property="article:published_time" content="2020-06-10T11:54:00.000Z">
<meta property="article:modified_time" content="2020-06-10T14:25:37.326Z">
<meta property="article:author" content="panda">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/image/JavaSE.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/10/JavaSE/"/>





  <title>JavaSE | Panda的技术笔记</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Panda的技术笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/10/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="panda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Panda的技术笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaSE</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-10T19:54:00+08:00">
                2020-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧</p>
<a id="more"></a>

<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="一、什么是Java"><a href="#一、什么是Java" class="headerlink" title="一、什么是Java"></a>一、什么是Java</h2><h3 id="1、JavaSE"><a href="#1、JavaSE" class="headerlink" title="1、JavaSE"></a>1、JavaSE</h3><p><img src="/image/JavaSE.png" alt=""></p>
<ul>
<li>Java SE就是标准版，包含标准的JVM和标准库，</li>
<li>Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</li>
<li>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。</li>
</ul>
<h3 id="2、JDK与JRE"><a href="#2、JDK与JRE" class="headerlink" title="2、JDK与JRE"></a>2、JDK与JRE</h3><p><img src="/image/JDKJRE.png" alt=""></p>
<ul>
<li>JRE就是运行Java字节码的虚拟机。</li>
<li>但是，如果只有Java源码，要编译成Java字节码，就需要JDK；</li>
<li>JDK除了包含JRE，还提供了编译器、调试器等开发工具。</li>
<li>JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。</li>
</ul>
<h3 id="3、白皮书关键术语"><a href="#3、白皮书关键术语" class="headerlink" title="3、白皮书关键术语"></a>3、白皮书关键术语</h3><ul>
<li>面向对象：重点在数据对象和对象的接口上</li>
<li>网络能力：能够通过url打开和访问网络上的对象</li>
<li>健壮性：java编译器能够检测出一些其他语言仅在运行时才能检测出的错误；java不需要指针来构造数据结构，在必要时却能具有指针的能力</li>
<li>可移植性：数据类型规范</li>
<li>多线程：带来更好的交互和响应</li>
</ul>
<h2 id="二、java程序基础"><a href="#二、java程序基础" class="headerlink" title="二、java程序基础"></a>二、java程序基础</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><ul>
<li><p>整数类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code></p>
<ul>
<li><code>byte</code>：-128 ~ 127</li>
<li><code>short</code>: -32768 ~ 32767</li>
<li><code>int</code>: -2147483648 ~ 2147483647</li>
<li><code>long</code>: -9223372036854775808 ~ 9223372036854775807</li>
</ul>
</li>
<li><p>浮点数类型：<code>float</code>，<code>double</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f2 = <span class="number">3.14e38f</span>; <span class="comment">// 科学计数法表示的3.14x10^38（对于float类型，需要加上f后缀。）</span></span><br><span class="line"><span class="keyword">double</span> d3 = <span class="number">4.9e-324</span>; <span class="comment">// 科学计数法表示的4.9x10^-324</span></span><br><span class="line"><span class="comment">//float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符类型：<code>char</code></p>
</li>
<li><p>布尔类型：<code>boolean</code></p>
</li>
<li><p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量（根据习惯，常量名通常全部大写。）</p>
</li>
</ul>
<h3 id="2、计算"><a href="#2、计算" class="headerlink" title="2、计算"></a>2、计算</h3><ul>
<li><p>普通运算、自增自减</p>
</li>
<li><p>移位计算、与或运算</p>
</li>
<li><p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r = Math.abs(x - y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>溢出：<code>NaN</code>表示<strong>Not a Number</strong>   <code>Infinity</code>表示无穷大   <code>-Infinity</code>表示负无穷大</p>
</li>
<li><p>三元计算  <code>b ? x : y</code>会首先计算<strong>b</strong>，如果<strong>b</strong>为<code>true</code>，则只计算<strong>x</strong>，否则，只计算<strong>y</strong></p>
</li>
</ul>
<h3 id="3、字符串"><a href="#3、字符串" class="headerlink" title="3、字符串"></a>3、字符串</h3><ul>
<li><p><code>\n</code>表示换行符</p>
</li>
<li><p><code>\r</code> 表示回车符</p>
</li>
<li><p><code>\t</code> 表示Tab</p>
</li>
<li><p>从Java 13开始//预览功能//，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（<code>Text Blocks</code>）了。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">	         SELECT * FROM</span></span><br><span class="line"><span class="string">	           users</span></span><br><span class="line"><span class="string">	         WHERE id &gt; 100</span></span><br><span class="line"><span class="string">	         ORDER BY name DESC</span></span><br><span class="line"><span class="string">           "</span><span class="string">""</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：<code>ORDER BY name DESC&quot;&quot;&quot;</code>;</li>
<li>多行字符串前面共同的空格会被去掉</li>
</ul>
</li>
<li><p>字符串匹配：两个<code>String</code>类型，它们的内容是相同的，但是，分别指向不同的对象，用<code>==</code>判断，结果为<code>false</code>，要判断引用类型的变量内容是否相等，必须使用<code>equals()</code>方法：<code>s1.equals(s2)</code></p>
</li>
</ul>
<h3 id="4、循环和流程"><a href="#4、循环和流程" class="headerlink" title="4、循环和流程"></a>4、循环和流程</h3><ul>
<li><p><code>while</code>循环是先判断循环条件，再执行循环。而另一种<code>do while</code>循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。</p>
</li>
<li><p>Java还提供了另一种<code>for each</code>循环，它可以更简单地遍历数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[]ns=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(intn:ns)&#123;</span><br><span class="line">  System.*out*.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>break</code>和<code>continue</code></p>
</li>
</ul>
<h3 id="5、数组操作"><a href="#5、数组操作" class="headerlink" title="5、数组操作"></a>5、数组操作</h3><ul>
<li>直接打印数组变量，得到的是数组在<strong>JVM</strong>中的引用地址</li>
<li>我们只需要调用<strong>JDK</strong>提供的<code>Arrays.sort()</code>就可以排序</li>
<li><code>Arrays.deepToString()</code>二维数组变字符串</li>
</ul>
<h2 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h2><h3 id="1、方法"><a href="#1、方法" class="headerlink" title="1、方法"></a>1、方法</h3><ul>
<li><p>可变参数用<code>类型…</code>定义，可变参数相当于数组类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String...names)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.names=names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）</p>
</li>
</ul>
<h3 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h3><ul>
<li><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。用<code>protected</code>修饰的字段可以被子类访问;</p>
</li>
<li><p>这是因为在<strong>Java</strong>中，任何<strong>class</strong>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super()</code>;</p>
</li>
<li><p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>

<p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（<code>upcasting</code>）。</p>
</li>
<li><p>向下转型很可能会失败（当出现多的功能和属性时）。失败的时候，<strong>Java</strong>虚拟机会报<code>ClassCastException</code></p>
</li>
<li><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    Student s = (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String) obj;</span><br><span class="line">    System.out.println(s.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、组合"><a href="#3、组合" class="headerlink" title="3、组合"></a>3、组合</h3><ul>
<li><p>具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4、覆写和多态"><a href="#4、覆写和多态" class="headerlink" title="4、覆写和多态"></a>4、覆写和多态</h3><ul>
<li>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</li>
<li><strong>Java</strong>的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run();<span class="comment">//应该打印Student.run</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。多态允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</li>
</ul>
<h3 id="5、final"><a href="#5、final" class="headerlink" title="5、final"></a>5、final</h3><ul>
<li>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。</li>
<li>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。</li>
<li>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。</li>
</ul>
<h3 id="6、Object方法"><a href="#6、Object方法" class="headerlink" title="6、Object方法"></a>6、Object方法</h3><ul>
<li><p>Object是对象的最高级别的，所有的Java对象都<strong>隐式</strong>地继承了Object对象。</p>
</li>
<li><p><code>toString()</code>：把<code>instance</code>输出为<code>String</code>；</p>
</li>
<li><p><code>equals()</code>：判断两个<code>instance</code>是否逻辑相等；</p>
</li>
<li><p><code>hashCode()</code>：计算一个<code>instance</code>的哈希值。</p>
</li>
</ul>
<h3 id="7、抽象类"><a href="#7、抽象类" class="headerlink" title="7、抽象类"></a>7、抽象类</h3><ul>
<li><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（<code>abstract class</code>）。</p>
</li>
<li><p>继承一个抽象类，就必须覆写抽象方法</p>
</li>
</ul>
<h3 id="8、接口"><a href="#8、接口" class="headerlink" title="8、接口"></a>8、接口</h3><ul>
<li><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以实现多个<code>interface</code></p>
</li>
<li><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
</li>
<li><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code></p>
</li>
<li><p>在接口中，可以定义<code>default</code>方法。实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
</li>
</ul>
<h3 id="9、静态字段和静态方法"><a href="#9、静态字段和静态方法" class="headerlink" title="9、静态字段和静态方法"></a>9、静态字段和静态方法</h3><ul>
<li><p>在一个<code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p>
</li>
<li><p>还有一种字段，是用static修饰的字段，称为静态字段：<code>static field</code>。静态字段只有一个共享“空间”，所有实例都会共享该字段。对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了。</p>
</li>
<li><p>把静态字段理解成类的字段而非实例的字段。</p>
</li>
<li><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p>
</li>
<li><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型。实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>{
    <span class="comment">// 编译器会自动加上public statc final:</span>
    <span class="keyword">int</span> MALE = <span class="number">1</span>;
    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;
}
&lt;!--￼<span class="number">14</span>--&gt;</code></pre>
</li>
<li><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"  \tHello\r\n "</span>.trim(); <span class="comment">// "Hello"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p>
</li>
<li><pre><code class="java"><span class="string">""</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span>
<span class="string">"  "</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span>
<span class="string">"  \n"</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span>
<span class="string">" Hello "</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span>
&lt;!--￼<span class="number">16</span>--&gt;

另一种是通过正则表达式替换：

&lt;!--￼<span class="number">17</span>--&gt;</code></pre>
</li>
<li><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"A,B,C,D"</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">"\\,"</span>); <span class="comment">// &#123;"A", "B", "C", "D"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">"***"</span>, arr); <span class="comment">// "A***B***C"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p>
</li>
<li><pre><code class="java">String.valueOf(<span class="number">123</span>); <span class="comment">// "123"</span>
String.valueOf(<span class="number">45.67</span>); <span class="comment">// "45.67"</span>
String.valueOf(<span class="keyword">true</span>); <span class="comment">// "true"</span>
String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span>
&lt;!--￼<span class="number">20</span>--&gt;

如果修改了`<span class="keyword">char</span>[]`数组，`String`并不会改变,采用复制一份的方法。</code></pre>
</li>
<li><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p>
</li>
<li><pre><code class="java"><span class="keyword">byte</span>[] b1 = <span class="string">"Hello"</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span>
<span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>); <span class="comment">// 按UTF-8编码转换</span>
<span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"GBK"</span>); <span class="comment">// 按GBK编码转换</span>
<span class="keyword">byte</span>[] b3 = <span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span>
&lt;!--￼<span class="number">21</span>--&gt;</code></pre>
</li>
<li><p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串</p>
</li>
<li><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>它是一个可变对象，可以预分配缓冲区，</p>
</li>
<li><pre><code class="java">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
    sb.append(<span class="string">','</span>);
    sb.append(i);
}
String s = sb.toString();
&lt;!--￼<span class="number">22</span>--&gt;

进行链式操作的关键是，定义的`append()`方法会返回`<span class="keyword">this</span>`</code></pre>
</li>
<li><p><code>String</code>还提供了一个静态方法<code>join()</code></p>
</li>
<li><pre><code class="java">String[] names = {<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Grace"</span>};
<span class="keyword">var</span> s = String.join(<span class="string">", "</span>, names);
&lt;!--￼<span class="number">23</span>--&gt;</code></pre>
</li>
<li><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p>
<p><img src="/image/class.png" alt=""></p>
</li>
<li><p>因为<code>int</code>和<code>Integer</code>可以互相转换，所以，<strong>Java</strong>编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型，这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（<code>Auto Boxing</code>），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（<code>Auto Unboxing</code>）。</p>
</li>
<li><p>所有的包装类型都是不变类。对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较。</p>
</li>
<li><p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p>
</li>
<li><ul>
<li><p>方法1：<code>Integer n = new Integer(100)</code>;</p>
</li>
<li><p>方法2：<code>Integer n = Integer.valueOf(100)</code></p>
</li>
<li><p><code>方法2</code>更好，因为<code>方法1</code>总是创建新的<code>Integer</code>实例，<code>方法2</code>把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p>
</li>
<li><p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p>
</li>
</ul>
</li>
<li><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数。<code>Integer</code>还可以把整数格式化为指定进制的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.toString(<span class="number">100</span>,<span class="number">36</span>);<span class="comment">//"2s",表示36进制</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java</strong>的包装类型还定义了一些有用的静态变量</p>
</li>
<li><pre><code class="java"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span>
Boolean t = Boolean.TRUE;
Boolean f = Boolean.FALSE;
<span class="comment">// int可表示的最大/最小值:</span>
<span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">// 2147483647</span>
<span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">// -2147483648</span>
<span class="comment">// long类型占用的bit和byte数量:</span>
<span class="keyword">int</span> sizeOfLong = Long.SIZE; <span class="comment">// 64 (bits)</span>
<span class="keyword">int</span> bytesOfLong = Long.BYTES; <span class="comment">// 8 (bytes)</span>
&lt;!--￼<span class="number">25</span>--&gt;
</code></pre>
</li>
</ul>
<h3 id="3、枚举类"><a href="#3、枚举类" class="headerlink" title="3、枚举类"></a>3、枚举类</h3><ul>
<li><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Weekday day = Weekday.SUN;
        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) {
            System.out.println(<span class="string">"Work at home!"</span>);
        } <span class="keyword">else</span> {
            System.out.println(<span class="string">"Work at office!"</span>);
        }
    }
}

<span class="keyword">enum</span> Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
&lt;!--￼<span class="number">26</span>--&gt;

这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<span class="keyword">int</span>值。
</code></pre>
</li>
</ul>
<h3 id="4、BigInteger和BigDecimal"><a href="#4、BigInteger和BigDecimal" class="headerlink" title="4、BigInteger和BigDecimal"></a>4、BigInteger和BigDecimal</h3><ul>
<li><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p>
</li>
<li><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算</p>
</li>
<li><pre><code class="java">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">"1234567890"</span>);
BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);
BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span>
&lt;!--￼<span class="number">27</span>--&gt;

如果一个`BigDecimal`的`scale()`返回负数，例如，`-<span class="number">2</span>`，表示这个数是个整数，并且末尾有<span class="number">2</span>个`<span class="number">0</span>`。</code></pre>
</li>
<li><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456789"</span>);</span><br><span class="line">BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等</p>
</li>
<li><p>使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回<code>负数</code>、<code>正数</code>和<code>0</code>，分别表示小于、大于和等于。</p>
</li>
</ul>
<h3 id="5、Math"><a href="#5、Math" class="headerlink" title="5、Math"></a>5、Math</h3><ul>
<li>求绝对值： <code>Math.abs(-100); // 100</code><pre><code>`Math.abs(-7.8); // 7.8`</code></pre></li>
<li>取最大或最小值：<code>Math.max(100, 99); // 100</code><pre><code>`Math.min(1.2, 2.3); // 1.2`</code></pre></li>
<li>计算<code>x</code>y次方：<code>Math.pow(2,      10); // 2的10次方=1024</code></li>
<li>计算<code>√x</code>：<code>Math.sqrt(2);      // 1.414…</code></li>
<li>计算<code>e</code>x次方：<code>Math.exp(2);      // 7.389…</code></li>
<li>计算以<code>e</code>为底的对数：<code>Math.log(4);      // 1.386…</code></li>
<li>计算以10为底的对数：<code>Math.log10(100);      // 2</code></li>
<li>三角函数：<code>Math.sin(3.14); // 0.00159…</code><pre><code>` Math.cos(3.14); // -0.9999...`
` Math.tan(3.14); // -0.0015…`
` Math.asin(1.0); // 1.57079...`
 `Math.acos(1.0); // 0.0`</code></pre></li>
<li>几个数学常量：<code>double pi = Math.PI; // 3.14159…</code><pre><code>` double e = Math.E; // 2.7182818…`
 `Math.sin(Math.PI / 6); // sin(π/6) = 0.5`</code></pre></li>
<li>生成一个随机数<code>x</code>，<code>x</code>的范围是<code>0 &lt;= x &lt; 1</code>：<code>Math.random(); //      0.53907...</code>每次都不一样</li>
</ul>
<h3 id="6、Random和SecureRandom"><a href="#6、Random和SecureRandom" class="headerlink" title="6、Random和SecureRandom"></a>6、Random和SecureRandom</h3><ul>
<li><p>Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p>
</li>
<li><p><code>SecureRandom</code>是用来创建安全的随机数的</p>
</li>
<li><pre><code class="java">SecureRandom sr = <span class="keyword">new</span> SecureRandom();
System.out.println(sr.nextInt(<span class="number">100</span>));
&lt;!--￼<span class="number">31</span>--&gt;</code></pre>
</li>
<li><p><img src="/image/exception.png" alt=""></p>
</li>
<li><p><code>Throwable</code>是异常体系的根，<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，</p>
</li>
<li><ul>
<li><code>Error</code>表示严重的错误，程序对此一般无能为力，</li>
<li>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</li>
</ul>
</li>
<li><p>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为<code>Checked Exception</code>。</p>
</li>
<li><p>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ul>
<h3 id="2、捕获异常"><a href="#2、捕获异常" class="headerlink" title="2、捕获异常"></a>2、捕获异常</h3><ul>
<li><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try {…}</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类：</p>
</li>
<li><p>还有一些童鞋喜欢在函数内部“消化”异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 什么也不干</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。<strong>JVM</strong>在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后不再继续匹配。存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面。</p>
</li>
<li><p>那么如何消除这些重复的代码？<strong>Java</strong>的<code>try … catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。<code>finally</code>语句不是必须的，可写可不写；<code>finally</code>总是最后执行。</p>
</li>
<li><p>某些情况下，可以没有<code>catch</code>，只使用<code>try … finally</code>结构。</p>
</li>
<li><p>如果处理某两个异常的代码是相同的，所以我们可以把它两用<code>|</code>合并到一起</p>
</li>
</ul>
<h3 id="3、抛出异常"><a href="#3、抛出异常" class="headerlink" title="3、抛出异常"></a>3、抛出异常</h3><ul>
<li><p>需要捕获异常的语句，一般在定义时会抛出一个异常：</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException{
  ....
}
&lt;!--￼<span class="number">33</span>--&gt;</code></pre>
</li>
<li><p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了。但是新的异常丢失了原始异常信息，我们已经看不到原始异常的信息了。为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例作为参数传进去。<strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</strong></p>
</li>
<li><p><code>finally</code>抛出异常后，原来在<code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（<code>Suppressed Exception</code>）我们一般先用<code>origin</code>变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在<code>finally</code>抛出</p>
</li>
</ul>
<h3 id="4、自定义异常"><a href="#4、自定义异常" class="headerlink" title="4、自定义异常"></a>4、自定义异常</h3><ul>
<li>自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。<code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生</li>
</ul>
<h3 id="5、断言"><a href="#5、断言" class="headerlink" title="5、断言"></a>5、断言</h3><ul>
<li>语句<code>assert x &gt;= 0</code>;即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</li>
<li>Java断言的特点是：断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</li>
<li>断言需要命令行开启。</li>
</ul>
<h3 id="6、JDK-logging"><a href="#6、JDK-logging" class="headerlink" title="6、JDK logging"></a>6、JDK logging</h3><ul>
<li><p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p>
</li>
<li><ol>
<li>可以设置输出样式，避免自己每次都写”ERROR: “ + var；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以……</li>
</ol>
</li>
<li><p><img src="/image/log1.png" alt=""></p>
</li>
<li><p><img src="/image/log2.png" alt=""></p>
</li>
<li><p>和Java标准库提供的日志不同，<code>Commons Logging</code>是一个第三方日志库，它是由Apache创建的日志模块。</p>
</li>
<li><p>使用<code>Commons Logging</code>只需要和两个类打交道，并且只有两步：第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； 第二步，使用<code>Log</code>实例的方法打日志。（需要apache的第三方包）</p>
</li>
<li><p><code>Log4j</code>是一种非常流行的日志框架，最新版本是2.x。当我们使用<code>Log4j</code>输出一条日志时，<code>Log4j</code>自动通过不同的<code>Appender</code>把同一条日志输出到不同的目的地。</p>
</li>
</ul>
<h2 id="六、反射"><a href="#六、反射" class="headerlink" title="六、反射"></a>六、反射</h2><h3 id="1、反射"><a href="#1、反射" class="headerlink" title="1、反射"></a>1、反射</h3><ul>
<li><p>动态语言和讲台语言</p>
<ul>
<li>动态语言是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的 函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自 身结构。主要动态语言:Object-C、C#、JavaScript、PHP、Python等。</li>
<li>静态语言与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。 Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用 反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活!</li>
</ul>
</li>
<li><p>Reflection(反射)是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取</p>
<p>得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"java.lang.String"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java<strong>反射机制提供的功能</strong></p>
<ul>
<li>在运行时构造任意一个类的对象 </li>
<li>在运行时判断任意一个类所具有的成员变量和方法 </li>
<li>在运行时获取泛型信息 </li>
<li>在运行时调用任意一个对象的成员变量和方法 </li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
</li>
<li><p>Java<strong>反射优点和缺点</strong></p>
<ul>
<li><p>优点:可以实现动态创建对象和编译，体现出很大的灵活性 !</p>
</li>
<li><p>缺点:对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满 足我们的要求。这类操作总是慢于 直接执行相同的操作。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2、Class实例"><a href="#2、Class实例" class="headerlink" title="2、Class实例"></a>2、Class实例</h3><ul>
<li><p><code>class</code>是由<strong>JVM</strong>在执行过程中动态加载的。<strong>JVM</strong>在第一次读取到一种<code>class</code>类型时，将其加载进内存。每加载一种<code>class</code>，<strong>JVM</strong>就为其创建一个<code>Class</code>类型的实例，并关联起来。这个<code>Class</code>实例是<strong>JVM</strong>内部创建的，如果我们查看<strong>JDK</strong>源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有<strong>JVM</strong>能创建<code>Class</code>实例，我们自己的<strong>Java</strong>程序是无法创建<code>Class</code>实例的。</p>
</li>
<li><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（<code>Reflection</code>）</p>
<ul>
<li>Class 本身也是一个类</li>
<li>Class 对象只能由系统建立对象</li>
<li>一个加载的类在 JVM 中只会有一个Class实例 </li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件 </li>
<li>每个类的实例都会记得自己是由哪个 Class 实例所生成 </li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构 </li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
</li>
<li><p>在Object类中定义了以下的方法，此方法将被所有子类继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">getClass</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来 看也很好理解，即:可以通过对象反射求出类的名称。</p>
</li>
<li><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>
<ul>
<li><p>直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>; </span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>只针对内置的基本数据类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Integer.TYPE;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取父类的class:<code>getSuperclass()</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = cls2.getSuperclass();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line">Object<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Number</span>.<span class="title">class</span>)</span>; <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3、Class实例方法"><a href="#3、Class实例方法" class="headerlink" title="3、Class实例方法"></a>3、Class实例方法</h3><ul>
<li><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。一个类只对应一个Class对象。</p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static ClassforName(String name)</td>
<td>返回指定类名name的Class对象</td>
</tr>
<tr>
<td>Object newInstance()</td>
<td>调用缺省构造函数，返回Class对象的一个实例</td>
</tr>
<tr>
<td>getName()</td>
<td>返回此Class对象所表示的实体(类，接口，数组类或 void)的名称。</td>
</tr>
<tr>
<td>Class getSuperClass()</td>
<td>返回当前Class对象的父类的Class对象</td>
</tr>
<tr>
<td>Class[] getinterfaces()</td>
<td>获取当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Constructor[] getConstructors()</td>
<td>返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td>Method getMothed(String name,Class.. T)</td>
<td>返回一个Method对象，此对象的形参类型为paramType</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>返回Field对象的一个数组</td>
</tr>
</tbody></table>
</li>
<li><p>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li><code>Field getField(name)</code>：根据字段名获取某个<code>public</code>的<code>field</code>（包括父类）</li>
<li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个<code>field</code>（不包括父类）</li>
<li><code>Field[] getFields()</code>：获取所有<code>public</code>的<code>field</code>（包括父类）</li>
<li><code>Field[] getDeclaredFields()</code>：获取当前类的所有<code>field</code>（不包括父类）</li>
</ul>
</li>
<li><pre><code class="java">Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;
<span class="comment">// 获取public字段"score":</span>
System.out.println(stdClass.getField(<span class="string">"score"</span>));<span class="comment">//public int Student.score</span>
<span class="comment">// 获取继承的public字段"name":</span>
System.out.println(stdClass.getField(<span class="string">"name"</span>));<span class="comment">//public java.lang.String Person.name</span>
<span class="comment">// 获取private字段"grade":</span>
System.out.println(stdClass.getDeclaredField(<span class="string">"grade"</span>));<span class="comment">//private int Student.grade</span>

&lt;!--￼<span class="number">42</span>--&gt;</code></pre>
</li>
<li><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;
}

Field f = String.class.getDeclaredField("value");
f.getName(); <span class="comment">// "value"</span>
f.getType(); <span class="comment">// class [B 表示byte[]类型</span>
<span class="keyword">int</span> m = f.getModifiers();
Modifier.isFinal(m); <span class="comment">// true</span>
Modifier.isPublic(m); <span class="comment">// false</span>
Modifier.isProtected(m); <span class="comment">// false</span>
Modifier.isPrivate(m); <span class="comment">// true</span>
Modifier.isStatic(m); <span class="comment">// false</span>
&lt;!--￼<span class="number">43</span>--&gt;</code></pre>
</li>
<li><p>用<code>getInterfaces</code>获取接口实例</p>
</li>
<li><pre><code class="java">Class s = Integer<span class="class">.<span class="keyword">class</span></span>;
Class[] is = s.getInterfaces();
&lt;!--￼<span class="number">44</span>--&gt;
</code></pre>
</li>
</ul>
<h3 id="3、class实例构造方法"><a href="#3、class实例构造方法" class="headerlink" title="3、class实例构造方法"></a>3、class实例构造方法</h3><ul>
<li><p>我们通常使用<code>new</code>操作符创建新的实例</p>
</li>
<li><pre><code class="java">Person p = <span class="keyword">new</span> Person();
&lt;!--￼<span class="number">45</span>--&gt;

调用`Class.newInstance()`的局限是，它只能调用该类的`<span class="keyword">public</span>`无参数构造方法。如果构造方法带有参数，或者不是`<span class="keyword">public</span>`，就无法直接通过`Class.newInstance()`来调用。</code></pre>
</li>
<li><p>为了调用任意的构造方法，Java的反射API提供了<code>Constructor</code>对象，它包含一个构造方法的所有信息，可以创建一个实例。</p>
</li>
<li><p>通过Class实例获取Constructor的方法如下：</p>
<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
</li>
<li><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"无参构造器"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"int 有参构造器"</span>+a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">A</span><span class="params">(String b,String a)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"私有String 有参构造器"</span>+b+a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, SecurityException </span>&#123;</span><br><span class="line">		Class clz = A<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		<span class="comment">//获得所有构造器：getDeclaredConstructors()返回所有权限的构造器、getConstructors()返回public权限的构造器</span></span><br><span class="line">		Constructor[] c = clz.getDeclaredConstructors();</span><br><span class="line">		<span class="keyword">for</span> (Constructor constructor : c) &#123;</span><br><span class="line">			System.out.println(constructor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//或得某一个 构造器</span></span><br><span class="line">		Constructor&lt;A&gt; c1 = clz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;<span class="comment">//私有</span></span><br><span class="line">		System.out.println(c1);</span><br><span class="line">		Constructor&lt;A&gt; c2 = clz.getConstructor();<span class="comment">//公共</span></span><br><span class="line">		System.out.println(c2);</span><br><span class="line">    Constructor&lt;A&gt; c3 = clz.getConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//公共有参</span></span><br><span class="line">		System.out.println(c2);</span><br><span class="line">		<span class="comment">//通过public构造器 创建对象</span></span><br><span class="line">		A a = c2.newInstance(<span class="keyword">new</span> Object[]&#123;&#125;);<span class="comment">//创建对象时调用无参构造器 打印输出："无参构造器"</span></span><br><span class="line">		<span class="comment">// 通过private构造器 创建对象</span></span><br><span class="line">		c1.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置成可以通过私有构造器 创建对象</span></span><br><span class="line">		A b = c1.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">"1111"</span>,<span class="string">"2222"</span>&#125;);<span class="comment">//打印输出：  私有String 有参构造器11112222</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="4、动态代理"><a href="#4、动态代理" class="headerlink" title="4、动态代理"></a>4、动态代理</h3><ul>
<li><p>Java的<code>class</code>和<code>interface</code>的区别：</p>
<ul>
<li>可以实例化<code>class</code>（非<code>abstract</code>）</li>
<li>不能实例化<code>interface</code></li>
</ul>
</li>
<li><p><code>代理(Proxy)</code>是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象。</p>
<p>这样做的好处是:可以在目标对象实现的功能上,增加额外的功能补充,即扩展目标对象的功能。这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。</p>
</li>
<li><p>静态代理：在使用静态代理时,被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 接口</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IStar</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 真实对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LDHStar</span> <span class="keyword">implements</span> <span class="title">IStar</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"刘德华唱歌"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 代理类需要有真实对象的控制权 (引用)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ProxyManger</span> <span class="keyword">implements</span> <span class="title">IStar</span> </span>&#123;   </span><br><span class="line">   			<span class="comment">// 真实对象的引用</span></span><br><span class="line">        <span class="keyword">private</span> IStar star;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProxyManger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProxyManger</span><span class="params">(IStar star)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.star = star;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　　　System.out.println(<span class="string">"唱歌前准备"</span>);</span><br><span class="line">    　　　 star.sing();</span><br><span class="line">   　　　　System.out.println(<span class="string">"善后工作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建明星对象</span></span><br><span class="line">            IStar ldh = <span class="keyword">new</span> LDHStar();</span><br><span class="line">            ProxyManger proxy = <span class="keyword">new</span> ProxyManger(ldh);</span><br><span class="line">            proxy.sing();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.</li>
<li>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</li>
</ul>
</li>
<li><p>Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>
<ul>
<li>还有一种方式是动态代码，我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫<code>动态代理</code>。</li>
<li>在运行期动态创建一个<code>interface</code>实例的方法如下：    </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//定义一个InvocationHandler实例，它负责实现接口的方法调用；</span></span><br><span class="line">       InvocationHandler handler = <span class="keyword">new</span> InvocationHandler () &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">               System.out.println(method);</span><br><span class="line">               <span class="keyword">if</span> (method.getName().equals(<span class="string">"morning"</span>)) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"Good morning, "</span> + args[<span class="number">0</span>]);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">     	<span class="comment">//通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：</span></span><br><span class="line">       Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">           Hello<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), // <span class="title">ClassLoader</span>，通常就是接口类的<span class="title">ClassLoader</span></span></span><br><span class="line">           new Class[] &#123; Hello.class &#125;, // 传入要实现的接口，至少需要传入一个接口进去</span><br><span class="line">           handler); <span class="comment">// 传入处理调用方法的InvocationHandler实例</span></span><br><span class="line">       hello.morning(<span class="string">"Bob"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//将返回的Object强制转型为接口</span></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="七、注解"><a href="#七、注解" class="headerlink" title="七、注解"></a>七、注解</h2><h3 id="1、什么是注解"><a href="#1、什么是注解" class="headerlink" title="1、什么是注解"></a>1、什么是注解</h3><ul>
<li><p>注解(Annotation)是JDK5.0开始引入的新技术，它其实就是<strong>代码中的特殊标记</strong>，这些标记可以<strong>在编译、类加载、运行时被读取，并执行相对应的处理</strong>。</p>
</li>
<li><p>注解不是程序本身，但是可以对程序作出解释，可以被其他程序（编译器）读取。注解是以<code>@注释名</code>的形式存在，可以添加一些参数。</p>
</li>
<li><p>传统的方式，我们是通过<strong>配置文件(xml文件)来告诉类是如何运行的</strong>。有了注解技术以后，注解可以附加在packages，class，method，field上，我们就可以<strong>通过注解告诉他们该 如何运行</strong>。<strong>注解可以给类、方法上注入信息，相当于为他们添加了附加信息。</strong></p>
</li>
<li><p>Java的注解可以分为三类：</p>
<ol>
<li><p>第一类是由编译器使用的注解，例如：</p>
<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
</li>
<li><p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
</li>
<li><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
</li>
</ol>
</li>
</ul>
<h3 id="2、注解的使用"><a href="#2、注解的使用" class="headerlink" title="2、注解的使用"></a>2、注解的使用</h3><ul>
<li><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口</p>
</li>
<li><p>注解的参数类似无参数方法，方法的名称就是参数的名称。可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>
</li>
<li><p>如果参数名称为value，可以不写<code>value=</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有一个参数, 默认名字一般是value.使用可省略不写 </span></span><br><span class="line"><span class="meta">@MyAnnotation</span>3(<span class="string">"aaa"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在注解上<strong>定义的成员变量只能是String、数组、Class、枚举类、注解</strong></p>
</li>
<li><p>怎么把注解上的信息注入到方法上呢？？？我们<strong>利用的是反射技术</strong></p>
<p>步骤可分为三部：</p>
<ul>
<li><strong>反射出该类的方法</strong></li>
<li><strong>通过方法得到注解上具体的信息</strong></li>
<li><strong>将注解上的信息注入到方法上</strong></li>
</ul>
</li>
<li><p>我们<strong>通过注解来让该方法拥有这两个变量</strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解拥有什么属性，在修饰的时候就要给出相对应的值</span></span><br><span class="line"><span class="meta">@MyAnnotation</span>(username = <span class="string">"zhongfucheng"</span>, age = <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们可以在<strong>注解声明属性的时候，给出默认值</strong>。那么在修饰的时候，就可以不用具体指定了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义了两个成员变量</span></span><br><span class="line">    <span class="function">String <span class="title">username</span><span class="params">()</span> <span class="keyword">default</span> "zicheng"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MyAnnotation</span>()</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>还有一种特殊的情况，如果<strong>注解上只有一个属性，并且属性的名称为value</strong>，那么在使用的时候，我们可以不写value，直接赋值给它就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>2(<span class="string">"zhongfucheng"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="3、元注解"><a href="#3、元注解" class="headerlink" title="3、元注解"></a>3、元注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<ol>
<li><p>@Retention<strong>用于指定被修饰的Annotation被保留多长时间。</strong>需要在什么级别保存该注释信息，即在哪个阶段还有效。</p>
</li>
<li><p>@Target用于描述注解的使用范围(即:被描述的注解可以用在什么地方)。</p>
</li>
<li><p>@Documented说明该注解将被包含在javadoc中。</p>
</li>
</ol>
<p><img src="/image/@Documented.png" alt="image-20200607143738113"></p>
<ol start="2">
<li>@Inherited说明子类可以继承父类中的该注解。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解可以用在什么地方：方法，类型</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="comment">//表示需要在什么级别保存该注释信息，即在哪个阶段还有效</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//说明该注解将被包含在javadoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//说明子类可以继承父类中的该注解</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、基本注解"><a href="#4、基本注解" class="headerlink" title="4、基本注解"></a>4、基本注解</h3><ul>
<li>在java.lang包下存在着5个基本的Annotation，其中有3个Annotation我们是非常常见的了。</li>
</ul>
<ol>
<li><p>@override<strong>重写注解</strong></p>
<ul>
<li><p>@Overried只用于修饰方法，表示一个方法声明打算重写超类中的另一个方法声明。</p>
</li>
<li><p>@Overried是告诉编译器要检查<strong>该方法是实现父类的</strong>…可以帮我们避免一些低级的错误…比如，我们在实现equals()方法的时候，把euqals()打错了，那么<strong>编译器就会发现该方法并不是实现父类的，与注解@Override冲突，于是就会给予错误</strong>。</p>
</li>
</ul>
</li>
<li><p>@Deprecated<strong>过时注解</strong></p>
<ul>
<li><p>@Deprecated可以用于修辞方法,属性,类,表示不鼓励程序员使用这样的元素,通常是因为它很危险或者存在更好的选择。但是只是过时了, 并不是不能使用!</p>
</li>
<li><p>Java在设计的时候，可能觉得某些方法设计得不好，<strong>为了兼容以前的程序，是不能直接把它抛弃的，于是就设置它为过时</strong>。当我们在程序中调用它的时候，在IDE上会出现一条横杠，说明该方法是过时的。</p>
</li>
</ul>
</li>
<li><p>@SuppressWarnings<strong>抑制编译器警告注解</strong></p>
<ul>
<li>该注解在我们写程序的时候并不是很常见，我们可以用它来<strong>让编译器不给予我们警告</strong>。在类上添加了@SuppressWarnings这个注解，那么编译器就不会给予我们警告了</li>
<li>你需要添加一-个参数才能正确使用，这些参数都是已经定义好了的,我们选择性的使用就好了.<ol>
<li>@SuppressWarnings(“all”)</li>
<li>@SuppressWarnings(“unchecked”)</li>
<li>@SuppressWarnings(value={“unchecked”,“deprecation”})</li>
</ol>
</li>
</ul>
</li>
<li><p>@SafeVarargs <strong>Java 7“堆污染”警告</strong></p>
<ul>
<li>什么是堆污染呢？？<strong>当把一个不是泛型的集合赋值给一个带泛型的集合的时候</strong>，这种情况就很容易发生堆污染….</li>
</ul>
</li>
<li><p>@FunctionalInterface<strong>用来指定该接口是函数式接口</strong></p>
<ul>
<li>用该注解<strong>显示指定</strong>该接口是一个函数式接口。</li>
</ul>
</li>
</ol>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    panda
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://yoursite.com/2020/06/10/JavaSE/" title="JavaSE">http://yoursite.com/2020/06/10/JavaSE/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/10/JavaWeb/" rel="prev" title="JavaWeb">
                JavaWeb <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">panda</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java基础"><span class="nav-text">java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、什么是Java"><span class="nav-text">一、什么是Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、JavaSE"><span class="nav-text">1、JavaSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、JDK与JRE"><span class="nav-text">2、JDK与JRE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、白皮书关键术语"><span class="nav-text">3、白皮书关键术语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、java程序基础"><span class="nav-text">二、java程序基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、基本数据类型"><span class="nav-text">1、基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、计算"><span class="nav-text">2、计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、字符串"><span class="nav-text">3、字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、循环和流程"><span class="nav-text">4、循环和流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、数组操作"><span class="nav-text">5、数组操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、面向对象编程"><span class="nav-text">三、面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、方法"><span class="nav-text">1、方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、继承"><span class="nav-text">2、继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、组合"><span class="nav-text">3、组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、覆写和多态"><span class="nav-text">4、覆写和多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、final"><span class="nav-text">5、final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、Object方法"><span class="nav-text">6、Object方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、抽象类"><span class="nav-text">7、抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、接口"><span class="nav-text">8、接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、静态字段和静态方法"><span class="nav-text">9、静态字段和静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、枚举类"><span class="nav-text">3、枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、BigInteger和BigDecimal"><span class="nav-text">4、BigInteger和BigDecimal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、Math"><span class="nav-text">5、Math</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、Random和SecureRandom"><span class="nav-text">6、Random和SecureRandom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、捕获异常"><span class="nav-text">2、捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、抛出异常"><span class="nav-text">3、抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、自定义异常"><span class="nav-text">4、自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、断言"><span class="nav-text">5、断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、JDK-logging"><span class="nav-text">6、JDK logging</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、反射"><span class="nav-text">六、反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、反射"><span class="nav-text">1、反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、Class实例"><span class="nav-text">2、Class实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、Class实例方法"><span class="nav-text">3、Class实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、class实例构造方法"><span class="nav-text">3、class实例构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、动态代理"><span class="nav-text">4、动态代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、注解"><span class="nav-text">七、注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、什么是注解"><span class="nav-text">1、什么是注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、注解的使用"><span class="nav-text">2、注解的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、元注解"><span class="nav-text">3、元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、基本注解"><span class="nav-text">4、基本注解</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">panda</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
